<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>main</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-12-04">
<meta name="DC.source" content="main.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Sampling and Aliasing: Lab P-8 Digital Images: A/D and D/A. 3 Lab Exercise (authors: Matthew Lowery, Timothy Felt)</a>
</li>
<li>
<a href="#2">3.1a) Compare the original to the downsampled image. Which parts of the image show the aliasing effects most dramatically?</a>
</li>
<li>
<a href="#3">3.1b) Explain why the aliasing happens in the lighthouse image by using a &ldquo;frequency domain&rdquo; explanation</a>
</li>
<li>
<a href="#4">3.2a)</a>
</li>
<li>
<a href="#5">3.2b)</a>
</li>
<li>
<a href="#6">3.2c)</a>
</li>
<li>
<a href="#7">3.2d)</a>
</li>
<li>
<a href="#8">3.2e)</a>
</li>
<li>
<a href="#9">3.2f)</a>
</li>
<li>
<a href="#10">3.2g)</a>
</li>
</ul>
</div>
<h2 id="1">Sampling and Aliasing: Lab P-8 Digital Images: A/D and D/A. 3 Lab Exercise (authors: Matthew Lowery, Timothy Felt)</h2>
<pre class="codeinput">
<span class="comment">% make plot fonts pretty</span>
set(groot, <span class="string">'defaultTextInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'defaultLegendInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'defaultAxesTickLabelInterpreter'</span>, <span class="string">'latex'</span>);
set(groot, <span class="string">'defaultAxesFontName'</span>, <span class="string">'Times'</span>);
set(groot, <span class="string">'defaultTextFontName'</span>, <span class="string">'Times'</span>);
set(groot, <span class="string">'defaultAxesFontSize'</span>, 25);

<span class="comment">% import spfirst</span>
addpath(genpath(<span class="string">'../spfirst'</span>))
spfirst;

load(<span class="string">'lighthouse'</span>) <span class="comment">% load lighthouse image</span>
</pre>
<h2 id="2">3.1a) Compare the original to the downsampled image. Which parts of the image show the aliasing effects most dramatically?</h2>
<pre class="codeinput">
<span class="comment">% Plot the lighthouse image</span>
show_img(xx)
title(<span class="string">'Lighthouse Image'</span>);
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; <span class="comment">% lbwh</span>

<span class="comment">% Plot the downsampled lighthouse image</span>
xx_downsampled_2 = xx(1:2:end, 1:2:end);
show_img(xx_downsampled_2)
title(<span class="string">'Lighthouse Image Downsampled by 2'</span>, <span class="string">'Units'</span>,<span class="string">'normalized'</span>, <span class="string">'Position'</span>,[0.5 1.08 0]);

xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; <span class="comment">% lbwh</span>
<span class="comment">% exportgraphics(gcf, 'lhd2.png', 'BackgroundColor','none');</span>

<span class="comment">% Visually, the downsampled image appears very blurry and distorted where there are local changes or features in the original image. For example, while the textures on the surface of almost all of the structures (the shed on the left, the brick house and the brick lighthouse) are somewhat coherent in the original image, they are incoherent in the downsampled image. This is also the case in the edges of any of the objects, such as the edge between the lighthouse and the sky. On the other hand, the original image is less affected by downsampling for the regions of uniformity, such as the blue sky above the platform or more large scale objects like the structures themselves.</span>
</pre>
<pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 426.5000]
             YLim: [0.5000 326.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1100 0.7745 0.8150]
            Units: 'normalized'

  Use GET to show all properties

Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 213.5000]
             YLim: [0.5000 163.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1100 0.7745 0.8150]
            Units: 'normalized'

  Use GET to show all properties

</pre>
<img vspace="5" hspace="5" src="main_01.png" alt=""> <img vspace="5" hspace="5" src="main_02.png" alt=""> <h2 id="3">3.1b) Explain why the aliasing happens in the lighthouse image by using a &ldquo;frequency domain&rdquo; explanation</h2>
<pre class="codeinput">
<span class="comment">% If the original image (xx) has a sampling frequency of Fs = 1 sample per pixel, the sampling theorem details that the maximum possible frequency which can be represented by this sampling rate without aliasing is:</span>
<span class="comment">% F_nyquist = 0.5 * Fs</span>
<span class="comment">%           = 0.5 cycles per pixel.</span>
<span class="comment">% Thus, we can say that the highest possible articulated frequency in the original image (without aliasing) is 0.5 cycles per sample.</span>

<span class="comment">% For the downsampled image, xx_downsampled_2,</span>
<span class="comment">% Fs_down = Fs // 2</span>
<span class="comment">%         = 0.5 samples per pixel.</span>
<span class="comment">% F_nyquist_down = 0.5 * Fs_down</span>
<span class="comment">%                = 0.5 * 0.5</span>
<span class="comment">%                = 0.25 cycles per pixel</span>
<span class="comment">% Thus we can say the highest possible articulated frequency in this downsampled image (without aliasing) is at most 0.25 cycles per pixel.</span>

<span class="comment">% All this to say that if there are frequencies in the original image greater than 0.25 cycles/pixel, they will be aliased in the downsampled image. Thus if we get an estimation of the frequencies around a region where we visually detect aliasing, we now can mathematically confirm the aliasing (if they're higher than 0.25 cycles/pixel). We can estimate the frequencies in the fencepost region relatively easily as its clear high-oscillating patterns will let us deduce a 'period' between fenceposts. That is, if we zoom in between x(300, 210) in the original image, where they are oscillating the fastest, we can try to measure their frequencies by counting the number of dark (fencehole) pixels between two light (fence) pixels. Around that location, there is merely 1 dark pixel for between two light pixels, thus T_fence = 2 pixels / cycle and F_fence = 1/2 = 0.5 cycles / pixel. Clearly, this is greater than the maximum frequency the downsampled image can represent (0.25 cycles/pixel), thereby confirming aliasing.</span>


<span class="comment">% Plot where we are going to zoom in in the original image via a red rectangle.</span>
show_img(xx)
title(<span class="string">'Lighthouse Image'</span>);
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
h = gcf; h.Position = [100 100 600 450];
n1 = 292; n2 = 304;
m1 = 204; m2 = 213;
x = n1; y = m1; w = n2 - n1; h = m2 - m1; hold <span class="string">on</span>;
rectangle(<span class="string">'Position'</span>, [x, y, w, h], <span class="string">'EdgeColor'</span>, <span class="string">'r'</span>, <span class="string">'LineWidth'</span>, 2);
hold <span class="string">off</span>;
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; <span class="comment">% lbwh</span>
<span class="comment">% exportgraphics(gcf, 'lh.png', 'BackgroundColor','none');</span>

<span class="comment">% Plot original image zoomed in to the region above</span>
show_img(xx)
xlim([292 304]);
ylim([204 213]);
title(<span class="string">'LH in a High-frequency Fencepost region m=292-304, n=204-213'</span>);
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; <span class="comment">% lbwh</span>
<span class="comment">% exportgraphics(gcf, 'lhnoal.png', 'BackgroundColor','none');</span>


<span class="comment">% Plot the same region in the downsampled image</span>
show_img(xx_downsampled_2)
title(<span class="string">'Downsampled LH Image in the same Fencepost region'</span>);
xlim([floor(292/2) floor(304/2)]);
ylim([floor((204)/2) floor(213)/2]);
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
xlabel(<span class="string">'m'</span>); ylabel(<span class="string">'n'</span>)
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; <span class="comment">% lbwh</span>
<span class="comment">% exportgraphics(gcf, 'lhal.png', 'BackgroundColor','none');</span>


<span class="comment">% Summary: Lab P-8: 3.1 involved detecting aliasing in the setting of a digital image of a Lighthouse, versus the 1D problems usually discussed in class. Here aliasing and signal disruption is quite intuitive, as the lighthouse basically looks more blurry when aliasing occurs because we are trained to see objects in the world, whereas a time series might just look like squiggley line and thus its aliasing is something that we might not be able to recognize. This is why DSP matters: even when it is not intuitive to visually notice aliasing, we can detect it mathematically. For this specific problem, the lighthouse image was downsampled by a factor of two, and it was articulated from both of these perspectives that aliasing had occured. From a frequency-space standpoint using the sampling theorem that aliasing had occurred. To argue the latter, we estimated the frequency of a highly-oscillatory fencepost region of the original image, and showed that it was higher than the Nyquist frequency of the downsampled image.</span>
</pre>
<pre class="codeoutput">Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 426.5000]
             YLim: [0.5000 326.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1100 0.7745 0.8150]
            Units: 'normalized'

  Use GET to show all properties

Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 426.5000]
             YLim: [0.5000 326.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1100 0.7745 0.8150]
            Units: 'normalized'

  Use GET to show all properties

Image being scaled so that min value is 0 and max value is 255

ans = 

  Axes with properties:

             XLim: [0.5000 213.5000]
             YLim: [0.5000 163.5000]
           XScale: 'linear'
           YScale: 'linear'
    GridLineStyle: '-'
         Position: [0.1302 0.1100 0.7745 0.8150]
            Units: 'normalized'

  Use GET to show all properties

</pre>
<img vspace="5" hspace="5" src="main_03.png" alt=""> <img vspace="5" hspace="5" src="main_04.png" alt=""> <img vspace="5" hspace="5" src="main_05.png" alt=""> <h2 id="4">3.2a)</h2>
<pre class="codeinput">clear;

data = load(<span class="string">'lighthouse.mat'</span>, <span class="string">'xx'</span>); <span class="comment">% Load in Lighthouse.mat</span>
xx = data.xx;
xx3 = xx(1:3:end,1:3:end); <span class="comment">%downsample by 3. Aliasing will occur.</span>
M = 3; <span class="comment">%upsampling factor.</span>

xr1 = (-2).^(0:6);
L = length(xr1);
nn = ceil((0.999:1:4*L)/4);
xr1hold = xr1(nn);

<span class="comment">% for the above code, the interpolation factor is 4 because we are</span>
<span class="comment">% copying each point 4 times to stretch out the array.</span>
<span class="comment">% the values contained in nn is the original array but 4x the size with</span>
<span class="comment">% every number copied 4 times.</span>
</pre>
<h2 id="5">3.2b)</h2>
<pre class="codeinput">[xRL, xCL] = size(xx3); <span class="comment">%perform linear interpolation.</span>
nC = ceil((0.999:1:M*xCL)/M);
nR = ceil((0.999:1:M*xRL)/M);

xholdRows = xx3(:, nC); <span class="comment">%upsample the rows.</span>

figure;
subplot(1, 2, 1); imshow(xx3, []); title(<span class="string">'Downsampled Image (xx3)'</span>);
subplot(1, 2, 2); imshow(xholdRows, []); title(<span class="string">'Rows Interpolated (xholdrows)'</span>);

<span class="comment">% Compare sizes</span>
disp([<span class="string">'Size of xx3: '</span>, num2str(size(xx3))]);
disp([<span class="string">'Size of xholdrows: '</span>, num2str(size(xholdRows))]);
</pre>
<pre class="codeoutput">Size of xx3: 109  142
Size of xholdrows: 109  426
</pre>
<img vspace="5" hspace="5" src="main_06.png" alt=""> <h2 id="6">3.2c)</h2>
<pre class="codeinput">xhold = xholdRows(nR, :); <span class="comment">%finish upsampling</span>

figure;
subplot(1, 2, 1); imshow(xx, []); title(<span class="string">'Original Lighthouse (xx)'</span>);
subplot(1, 2, 2); imshow(xhold, []); title(<span class="string">'Final Upsampled Image (xhold)'</span>);

<span class="comment">% Compare sizes</span>
disp([<span class="string">'Size of xx: '</span>, num2str(size(xx))]);
disp([<span class="string">'Size of xhold: '</span>, num2str(size(xhold))]);
</pre>
<pre class="codeoutput">Size of xx: 326  426
Size of xhold: 327  426
</pre>
<img vspace="5" hspace="5" src="main_07.png" alt=""> <h2 id="7">3.2d)</h2>
<pre class="codeinput">n1 = 0:6;
xr1 = (-2).^n1;
tti = 0:0.1:6; <span class="comment">%-- locations between the n1 indices</span>
xr1linear = interp1(n1,xr1,tti); <span class="comment">%-- function is INTERP-ONE</span>
stem(tti,xr1linear);

<span class="comment">% the interpolation factor is 10. This is because for the original vector</span>
<span class="comment">% the spacing is 1. 0:6 Has a spacing of 1. When we convert it and use</span>
<span class="comment">% 0:0.1:6, we are adding 10 additional spaces between the integers giving</span>
<span class="comment">% it an interpolation factor of 10.</span>
</pre>
<img vspace="5" hspace="5" src="main_08.png" alt=""> <h2 id="8">3.2e)</h2>
<pre class="codeinput">[xRL, xCL] = size(xx3);
xR = (1:xRL);
xC = (1:xCL);
ttR = linspace(1, xRL, xRL * M);
ttC = linspace(1, xCL, xCL * M);

xx3_double = double(xx3);
<span class="keyword">for</span> r = 1:xRL
    <span class="comment">% Interpolate the current row of xx3 horizontally</span>
    <span class="comment">% Arguments: Known Coordinates (xC), Known Values (xx3(r, :)), Query Coordinates (ttC)</span>
    xhold_C(r, :) = interp1(xC, xx3_double(r, :), ttC, <span class="string">'linear'</span>);
<span class="keyword">end</span>

<span class="comment">% --- 3. Stage 2: Interpolate Rows (Vertical Expansion) ---</span>
<span class="comment">% Final image, named xxlinear, has (xRL*M) rows and (xCL*M) columns.</span>
xxlinear = zeros(xRL * M, xCL * M);

<span class="keyword">for</span> c = 1:(xCL * M)
    <span class="comment">% Interpolate the current column of the intermediate result (xhold_C) vertically</span>
    <span class="comment">% Arguments: Known Coordinates (xR), Known Values (xhold_C(:, c)), Query Coordinates (ttR)</span>
    xxlinear(:, c) = interp1(xR, xhold_C(:, c), ttR, <span class="string">'linear'</span>);
<span class="keyword">end</span>
</pre>
<h2 id="9">3.2f)</h2>
<pre class="codeinput">figure;
subplot(1, 2, 1); imshow(xx, []); title(<span class="string">'Original Image (xx)'</span>);
subplot(1, 2, 2); imshow(xxlinear, []); title(<span class="string">'Bilinear Interpolated (xxlinear)'</span>);

<span class="comment">%the images are the same size and look relatively the same in shape and</span>
<span class="comment">%color. However, the difference is that there are more edges on the</span>
<span class="comment">%reconstructed image, and the edges themselves are fuzzy.</span>
<span class="comment">%The zooming process cannot remove aliasing because zooming it in removes</span>
<span class="comment">%a lot of the points to make it smaller and causes aliasing.</span>
</pre>
<img vspace="5" hspace="5" src="main_09.png" alt=""> <h2 id="10">3.2g)</h2>
<pre class="codeinput">figure;
subplot(1, 2, 1); imshow(xhold, []); title(<span class="string">'ZeroHold (xhold)'</span>);
subplot(1, 2, 2); imshow(xxlinear, []); title(<span class="string">'Bilinear Interpolated (xxlinear)'</span>);

<span class="comment">%the edges on the linear interpolated seem a little softer and more fuzzy</span>
<span class="comment">%vs the edges on the zero hold that seem sharper and have higher contrast.</span>
</pre>
<img vspace="5" hspace="5" src="main_10.png" alt=""> <p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Sampling and Aliasing: Lab P-8 Digital Images: A/D and D/A. 3 Lab Exercise (authors: Matthew Lowery, Timothy Felt)

% make plot fonts pretty
set(groot, 'defaultTextInterpreter', 'latex'); 
set(groot, 'defaultLegendInterpreter', 'latex');
set(groot, 'defaultAxesTickLabelInterpreter', 'latex');
set(groot, 'defaultAxesFontName', 'Times');
set(groot, 'defaultTextFontName', 'Times');
set(groot, 'defaultAxesFontSize', 25); 

% import spfirst
addpath(genpath('../spfirst'))
spfirst;

load('lighthouse') % load lighthouse image

%% 3.1a) Compare the original to the downsampled image. Which parts of the image show the aliasing effects most dramatically?

% Plot the lighthouse image
show_img(xx)
title('Lighthouse Image');
xlabel('m'); ylabel('n')
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; % lbwh

% Plot the downsampled lighthouse image
xx_downsampled_2 = xx(1:2:end, 1:2:end);
show_img(xx_downsampled_2)
title('Lighthouse Image Downsampled by 2', 'Units','normalized', 'Position',[0.5 1.08 0]);

xlabel('m'); ylabel('n')
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; % lbwh
% exportgraphics(gcf, 'lhd2.png', 'BackgroundColor','none');

% Visually, the downsampled image appears very blurry and distorted where there are local changes or features in the original image. For example, while the textures on the surface of almost all of the structures (the shed on the left, the brick house and the brick lighthouse) are somewhat coherent in the original image, they are incoherent in the downsampled image. This is also the case in the edges of any of the objects, such as the edge between the lighthouse and the sky. On the other hand, the original image is less affected by downsampling for the regions of uniformity, such as the blue sky above the platform or more large scale objects like the structures themselves. 

%% 3.1b) Explain why the aliasing happens in the lighthouse image by using a “frequency domain” explanation

% If the original image (xx) has a sampling frequency of Fs = 1 sample per pixel, the sampling theorem details that the maximum possible frequency which can be represented by this sampling rate without aliasing is: 
% F_nyquist = 0.5 * Fs 
%           = 0.5 cycles per pixel.
% Thus, we can say that the highest possible articulated frequency in the original image (without aliasing) is 0.5 cycles per sample.

% For the downsampled image, xx_downsampled_2, 
% Fs_down = Fs // 2 
%         = 0.5 samples per pixel.
% F_nyquist_down = 0.5 * Fs_down 
%                = 0.5 * 0.5
%                = 0.25 cycles per pixel
% Thus we can say the highest possible articulated frequency in this downsampled image (without aliasing) is at most 0.25 cycles per pixel.  

% All this to say that if there are frequencies in the original image greater than 0.25 cycles/pixel, they will be aliased in the downsampled image. Thus if we get an estimation of the frequencies around a region where we visually detect aliasing, we now can mathematically confirm the aliasing (if they're higher than 0.25 cycles/pixel). We can estimate the frequencies in the fencepost region relatively easily as its clear high-oscillating patterns will let us deduce a 'period' between fenceposts. That is, if we zoom in between x(300, 210) in the original image, where they are oscillating the fastest, we can try to measure their frequencies by counting the number of dark (fencehole) pixels between two light (fence) pixels. Around that location, there is merely 1 dark pixel for between two light pixels, thus T_fence = 2 pixels / cycle and F_fence = 1/2 = 0.5 cycles / pixel. Clearly, this is greater than the maximum frequency the downsampled image can represent (0.25 cycles/pixel), thereby confirming aliasing. 


% Plot where we are going to zoom in in the original image via a red rectangle.
show_img(xx)
title('Lighthouse Image');
xlabel('m'); ylabel('n')
h = gcf; h.Position = [100 100 600 450];
n1 = 292; n2 = 304;
m1 = 204; m2 = 213;
x = n1; y = m1; w = n2 - n1; h = m2 - m1; hold on; 
rectangle('Position', [x, y, w, h], 'EdgeColor', 'r', 'LineWidth', 2);
hold off;
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; % lbwh
% exportgraphics(gcf, 'lh.png', 'BackgroundColor','none');

% Plot original image zoomed in to the region above
show_img(xx)
xlim([292 304]);
ylim([204 213]);
title('LH in a High-frequency Fencepost region m=292-304, n=204-213');
xlabel('m'); ylabel('n')
xlabel('m'); ylabel('n')
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; % lbwh
% exportgraphics(gcf, 'lhnoal.png', 'BackgroundColor','none');


% Plot the same region in the downsampled image
show_img(xx_downsampled_2)
title('Downsampled LH Image in the same Fencepost region');
xlim([floor(292/2) floor(304/2)]);
ylim([floor((204)/2) floor(213)/2]);
xlabel('m'); ylabel('n')
xlabel('m'); ylabel('n')
h = gcf; h.Position = [100 100 600 450];
ax = gca;
ax.TightInset;
ax.Position = [0.18 0.20 0.72 0.60]; % lbwh
% exportgraphics(gcf, 'lhal.png', 'BackgroundColor','none');


% Summary: Lab P-8: 3.1 involved detecting aliasing in the setting of a digital image of a Lighthouse, versus the 1D problems usually discussed in class. Here aliasing and signal disruption is quite intuitive, as the lighthouse basically looks more blurry when aliasing occurs because we are trained to see objects in the world, whereas a time series might just look like squiggley line and thus its aliasing is something that we might not be able to recognize. This is why DSP matters: even when it is not intuitive to visually notice aliasing, we can detect it mathematically. For this specific problem, the lighthouse image was downsampled by a factor of two, and it was articulated from both of these perspectives that aliasing had occured. From a frequency-space standpoint using the sampling theorem that aliasing had occurred. To argue the latter, we estimated the frequency of a highly-oscillatory fencepost region of the original image, and showed that it was higher than the Nyquist frequency of the downsampled image.


%% 3.2a)
clear;

data = load('lighthouse.mat', 'xx'); % Load in Lighthouse.mat
xx = data.xx;
xx3 = xx(1:3:end,1:3:end); %downsample by 3. Aliasing will occur.
M = 3; %upsampling factor.

xr1 = (-2).^(0:6);
L = length(xr1);
nn = ceil((0.999:1:4*L)/4);
xr1hold = xr1(nn);

% for the above code, the interpolation factor is 4 because we are
% copying each point 4 times to stretch out the array.
% the values contained in nn is the original array but 4x the size with
% every number copied 4 times.

%% 3.2b)

[xRL, xCL] = size(xx3); %perform linear interpolation.
nC = ceil((0.999:1:M*xCL)/M);
nR = ceil((0.999:1:M*xRL)/M);

xholdRows = xx3(:, nC); %upsample the rows.

figure;
subplot(1, 2, 1); imshow(xx3, []); title('Downsampled Image (xx3)');
subplot(1, 2, 2); imshow(xholdRows, []); title('Rows Interpolated (xholdrows)');

% Compare sizes
disp(['Size of xx3: ', num2str(size(xx3))]);
disp(['Size of xholdrows: ', num2str(size(xholdRows))]);
%% 3.2c)
xhold = xholdRows(nR, :); %finish upsampling

figure;
subplot(1, 2, 1); imshow(xx, []); title('Original Lighthouse (xx)');
subplot(1, 2, 2); imshow(xhold, []); title('Final Upsampled Image (xhold)');

% Compare sizes
disp(['Size of xx: ', num2str(size(xx))]);
disp(['Size of xhold: ', num2str(size(xhold))]);

%% 3.2d)

n1 = 0:6;
xr1 = (-2).^n1;
tti = 0:0.1:6; %REPLACE_WITH_DASH_DASH locations between the n1 indices
xr1linear = interp1(n1,xr1,tti); %REPLACE_WITH_DASH_DASH function is INTERP-ONE
stem(tti,xr1linear);

% the interpolation factor is 10. This is because for the original vector
% the spacing is 1. 0:6 Has a spacing of 1. When we convert it and use
% 0:0.1:6, we are adding 10 additional spaces between the integers giving
% it an interpolation factor of 10.

%% 3.2e)

[xRL, xCL] = size(xx3); 
xR = (1:xRL);
xC = (1:xCL);
ttR = linspace(1, xRL, xRL * M);
ttC = linspace(1, xCL, xCL * M);

xx3_double = double(xx3);
for r = 1:xRL
    % Interpolate the current row of xx3 horizontally
    % Arguments: Known Coordinates (xC), Known Values (xx3(r, :)), Query Coordinates (ttC)
    xhold_C(r, :) = interp1(xC, xx3_double(r, :), ttC, 'linear');
end

% REPLACE_WITH_DASH_DASH- 3. Stage 2: Interpolate Rows (Vertical Expansion) REPLACE_WITH_DASH_DASH-
% Final image, named xxlinear, has (xRL*M) rows and (xCL*M) columns.
xxlinear = zeros(xRL * M, xCL * M);

for c = 1:(xCL * M)
    % Interpolate the current column of the intermediate result (xhold_C) vertically
    % Arguments: Known Coordinates (xR), Known Values (xhold_C(:, c)), Query Coordinates (ttR)
    xxlinear(:, c) = interp1(xR, xhold_C(:, c), ttR, 'linear');
end

%% 3.2f)
figure;
subplot(1, 2, 1); imshow(xx, []); title('Original Image (xx)');
subplot(1, 2, 2); imshow(xxlinear, []); title('Bilinear Interpolated (xxlinear)');

%the images are the same size and look relatively the same in shape and
%color. However, the difference is that there are more edges on the
%reconstructed image, and the edges themselves are fuzzy.
%The zooming process cannot remove aliasing because zooming it in removes
%a lot of the points to make it smaller and causes aliasing.

%% 3.2g)
figure;
subplot(1, 2, 1); imshow(xhold, []); title('ZeroHold (xhold)');
subplot(1, 2, 2); imshow(xxlinear, []); title('Bilinear Interpolated (xxlinear)');

%the edges on the linear interpolated seem a little softer and more fuzzy
%vs the edges on the zero hold that seem sharper and have higher contrast.

##### SOURCE END #####
-->
</body>
</html>
